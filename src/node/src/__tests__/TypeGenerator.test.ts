import { TypeGenerator } from '../codegen/TypeGenerator';
import type { BundleDefinition } from '../schema/SchemaDefinition';

describe('TypeGenerator', () => {
  let generator: TypeGenerator;

  beforeEach(() => {
    generator = new TypeGenerator({ includeJSDoc: true });
  });

  describe('generateInterface', () => {
    it('should generate basic interface', () => {
      const bundle: BundleDefinition = {
        name: 'User',
        fields: [
          { name: 'id', type: 'STRING', required: true, unique: true },
          { name: 'email', type: 'STRING', required: true, unique: true }
        ],
        indexes: []
      };

      const code = generator.generateInterface(bundle);

      expect(code).toContain('export interface User {');
      expect(code).toContain('id: string;');
      expect(code).toContain('email: string;');
      expect(code).toContain('@generated Auto-generated by SyndrDB type generator');
    });

    it('should handle optional fields', () => {
      const bundle: BundleDefinition = {
        name: 'Post',
        fields: [
          { name: 'id', type: 'STRING', required: true, unique: true },
          { name: 'title', type: 'STRING', required: true, unique: false },
          { name: 'subtitle', type: 'STRING', required: false, unique: false }
        ],
        indexes: []
      };

      const code = generator.generateInterface(bundle);

      expect(code).toContain('id: string;');
      expect(code).toContain('title: string;');
      expect(code).toContain('subtitle?: string;');
    });

    it('should map all field types correctly', () => {
      const bundle: BundleDefinition = {
        name: 'TestBundle',
        fields: [
          { name: 'stringField', type: 'STRING', required: true, unique: false },
          { name: 'intField', type: 'INT', required: true, unique: false },
          { name: 'floatField', type: 'FLOAT', required: true, unique: false },
          { name: 'boolField', type: 'BOOLEAN', required: true, unique: false },
          { name: 'dateField', type: 'DATETIME', required: true, unique: false },
          { name: 'jsonField', type: 'JSON', required: true, unique: false },
          { name: 'textField', type: 'TEXT', required: true, unique: false }
        ],
        indexes: []
      };

      const code = generator.generateInterface(bundle);

      expect(code).toContain('stringField: string;');
      expect(code).toContain('intField: number;');
      expect(code).toContain('floatField: number;');
      expect(code).toContain('boolField: boolean;');
      expect(code).toContain('dateField: Date;');
      expect(code).toContain('jsonField: any;');
      expect(code).toContain('textField: string;');
    });

    it('should handle relationship fields', () => {
      const bundle: BundleDefinition = {
        name: 'Order',
        fields: [
          { name: 'id', type: 'STRING', required: true, unique: true },
          { name: 'user', type: 'relationship', required: true, unique: false, relatedBundle: 'User' }
        ],
        indexes: []
      };

      const code = generator.generateInterface(bundle);

      expect(code).toContain('user: User;');
    });

    it('should support custom type mappings', () => {
      const customGenerator = new TypeGenerator({
        customMappings: {
          'STRING': 'string | null',
          'INT': 'bigint'
        }
      });

      const bundle: BundleDefinition = {
        name: 'Custom',
        fields: [
          { name: 'str', type: 'STRING', required: true, unique: false },
          { name: 'num', type: 'INT', required: true, unique: false }
        ],
        indexes: []
      };

      const code = customGenerator.generateInterface(bundle);

      expect(code).toContain('str: string | null;');
      expect(code).toContain('num: bigint;');
    });

    it('should generate without JSDoc when disabled', () => {
      const noDocGenerator = new TypeGenerator({ includeJSDoc: false });

      const bundle: BundleDefinition = {
        name: 'Simple',
        fields: [{ name: 'id', type: 'STRING', required: true, unique: true }],
        indexes: []
      };

      const code = noDocGenerator.generateInterface(bundle);

      expect(code).not.toContain('/**');
      expect(code).not.toContain('@generated');
      expect(code).toContain('export interface Simple {');
    });

    it('should make all fields optional when makeOptional is true', () => {
      const optionalGenerator = new TypeGenerator({ makeOptional: true });

      const bundle: BundleDefinition = {
        name: 'Optional',
        fields: [
          { name: 'id', type: 'STRING', required: true, unique: true },
          { name: 'name', type: 'STRING', required: true, unique: false }
        ],
        indexes: []
      };

      const code = optionalGenerator.generateInterface(bundle);

      expect(code).toContain('id?: string;');
      expect(code).toContain('name?: string;');
    });
  });

  describe('generateTypeGuard', () => {
    it('should generate type guard function', () => {
      const bundle: BundleDefinition = {
        name: 'User',
        fields: [
          { name: 'id', type: 'STRING', required: true, unique: true },
          { name: 'email', type: 'STRING', required: true, unique: true }
        ],
        indexes: []
      };

      const code = generator.generateTypeGuard(bundle);

      expect(code).toContain('export function isUser(obj: any): obj is User {');
      expect(code).toContain("if (!obj || typeof obj !== 'object') return false;");
      expect(code).toContain("typeof obj.id === 'string'");
      expect(code).toContain("typeof obj.email === 'string'");
      expect(code).toContain('return true;');
    });

    it('should only check required fields', () => {
      const bundle: BundleDefinition = {
        name: 'Post',
        fields: [
          { name: 'id', type: 'STRING', required: true, unique: true },
          { name: 'title', type: 'STRING', required: true, unique: false },
          { name: 'subtitle', type: 'STRING', required: false, unique: false }
        ],
        indexes: []
      };

      const code = generator.generateTypeGuard(bundle);

      expect(code).toContain("typeof obj.id === 'string'");
      expect(code).toContain("typeof obj.title === 'string'");
      expect(code).not.toContain('subtitle');
    });

    it('should handle different field types in checks', () => {
      const bundle: BundleDefinition = {
        name: 'Data',
        fields: [
          { name: 'count', type: 'INT', required: true, unique: false },
          { name: 'active', type: 'BOOLEAN', required: true, unique: false },
          { name: 'createdAt', type: 'DATETIME', required: true, unique: false }
        ],
        indexes: []
      };

      const code = generator.generateTypeGuard(bundle);

      expect(code).toContain("typeof obj.count === 'number'");
      expect(code).toContain("typeof obj.active === 'boolean'");
      expect(code).toContain('obj.createdAt instanceof Date');
    });
  });

  describe('generateInterfaces', () => {
    it('should generate multiple interfaces', () => {
      const bundles: BundleDefinition[] = [
        {
          name: 'User',
          fields: [{ name: 'id', type: 'STRING', required: true, unique: true }],
          indexes: []
        },
        {
          name: 'Product',
          fields: [{ name: 'id', type: 'STRING', required: true, unique: true }],
          indexes: []
        }
      ];

      const code = generator.generateInterfaces(bundles);

      expect(code).toContain('export interface User {');
      expect(code).toContain('export interface Product {');
    });
  });
});
