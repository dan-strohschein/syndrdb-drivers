import type { BundleDefinition, FieldDefinition } from '../schema/SchemaDefinition';

/**
 * Options for type generation
 */
export interface TypeGeneratorOptions {
  /** Whether to include JSDoc comments */
  includeJSDoc?: boolean;
  /** Whether to make all fields optional */
  makeOptional?: boolean;
  /** Custom type mappings */
  customMappings?: Record<string, string>;
}

/**
 * Generates TypeScript type definitions from bundle schemas
 * Follows Single Responsibility Principle - only handles type code generation
 */
export class TypeGenerator {
  private readonly options: Required<TypeGeneratorOptions>;

  constructor(options: TypeGeneratorOptions = {}) {
    this.options = {
      includeJSDoc: options.includeJSDoc ?? true,
      makeOptional: options.makeOptional ?? false,
      customMappings: options.customMappings ?? {}
    };
  }

  /**
   * Generates TypeScript interface from bundle definition
   * @param bundle - Bundle definition
   * @returns TypeScript interface code
   */
  generateInterface(bundle: BundleDefinition): string {
    const lines: string[] = [];

    // Add JSDoc if enabled
    if (this.options.includeJSDoc) {
      lines.push('/**');
      lines.push(` * ${bundle.name} bundle`);
      lines.push(' * @generated Auto-generated by SyndrDB type generator');
      lines.push(' */');
    }

    // Interface declaration
    lines.push(`export interface ${bundle.name} {`);

    // Add fields
    for (const field of bundle.fields) {
      // Add field JSDoc
      if (this.options.includeJSDoc) {
        lines.push(`  /**`);
        lines.push(`   * ${field.name} field`);
        lines.push(`   * @type {${this.mapFieldType(field)}}`);
        if (!field.required && !this.options.makeOptional) {
          lines.push(`   * @optional`);
        }
        lines.push(`   */`);
      }

      // Add field declaration
      const optional = !field.required || this.options.makeOptional ? '?' : '';
      const tsType = this.mapFieldType(field);
      lines.push(`  ${field.name}${optional}: ${tsType};`);
    }

    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generates TypeScript interfaces from multiple bundles
   * @param bundles - Array of bundle definitions
   * @returns TypeScript code with all interfaces
   */
  generateInterfaces(bundles: BundleDefinition[]): string {
    const interfaces = bundles.map(bundle => this.generateInterface(bundle));
    return interfaces.join('\n\n');
  }

  /**
   * Maps SyndrDB field type to TypeScript type
   * @param field - Field definition
   * @returns TypeScript type string
   */
  private mapFieldType(field: FieldDefinition): string {
    // Check custom mappings first
    if (this.options.customMappings[field.type]) {
      return this.options.customMappings[field.type];
    }

    // Handle relationship fields
    if (field.type === 'relationship') {
      if (!field.relatedBundle) {
        // TODO: Log warning about missing relatedBundle
        return 'any';
      }

      // Generate both ID and navigation property
      // For now, just return the related bundle type
      // TODO: Consider generating separate ID field (e.g., userId: string) and navigation property (e.g., user: User)
      return field.relatedBundle;
    }

    // Standard type mappings
    switch (field.type) {
      case 'STRING':
        return 'string';
      case 'INT':
      case 'INTEGER':
      case 'FLOAT':
        return 'number';
      case 'BOOLEAN':
        return 'boolean';
      case 'DATETIME':
        return 'Date';
      // case 'JSON': // These are not yet supported
      //   return 'any';
      // case 'TEXT':
      //   return 'string';
      default:
        // TODO: Consider adding warning system for unmapped types
        return 'any';
    }
  }

  /**
   * Generates type guard function for runtime type checking
   * @param bundle - Bundle definition
   * @returns TypeScript type guard code
   */
  generateTypeGuard(bundle: BundleDefinition): string {
    const lines: string[] = [];

    if (this.options.includeJSDoc) {
      lines.push('/**');
      lines.push(` * Type guard for ${bundle.name}`);
      lines.push(` * @param obj - Object to check`);
      lines.push(` * @returns True if object matches ${bundle.name} interface`);
      lines.push(' */');
    }

    lines.push(`export function is${bundle.name}(obj: any): obj is ${bundle.name} {`);
    lines.push(`  if (!obj || typeof obj !== 'object') return false;`);
    lines.push('');

    // Check required fields
    for (const field of bundle.fields) {
      if (field.required) {
        const typeCheck = this.generateRuntimeTypeCheck(field);
        lines.push(`  if (!(${typeCheck})) return false;`);
      }
    }

    lines.push('');
    lines.push(`  return true;`);
    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generates runtime type check expression for a field
   * @param field - Field definition
   * @returns JavaScript expression that checks field type
   */
  private generateRuntimeTypeCheck(field: FieldDefinition): string {
    const fieldAccess = `obj.${field.name}`;

    switch (field.type) {
      case 'STRING':
      case 'TEXT':
        return `typeof ${fieldAccess} === 'string'`;
      case 'INT':
      case 'INTEGER':
      case 'FLOAT':
        return `typeof ${fieldAccess} === 'number'`;
      case 'BOOLEAN':
        return `typeof ${fieldAccess} === 'boolean'`;
      case 'DATETIME':
        return `${fieldAccess} instanceof Date`;
      // case 'JSON':
      //   return `${fieldAccess} !== undefined`;
      case 'relationship':
        // TODO: Add deep type checking for related objects
        return `${fieldAccess} !== undefined`;
      default:
        return `${fieldAccess} !== undefined`;
    }
  }
}
