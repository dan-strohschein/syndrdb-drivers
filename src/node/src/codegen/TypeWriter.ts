import * as fs from 'fs/promises';
import * as path from 'path';

/**
 * Options for type writing
 */
export interface TypeWriterOptions {
  /** Output directory for generated types */
  outputDir?: string;
  /** Whether to create directory if it doesn't exist */
  createDir?: boolean;
  /** File header comment */
  header?: string;
}

/**
 * Writes generated TypeScript types to files
 * Follows Single Responsibility Principle - only handles file I/O for types
 */
export class TypeWriter {
  private readonly options: Required<TypeWriterOptions>;
  private readonly defaultOutputDir = '.syndrdb-types';

  constructor(options: TypeWriterOptions = {}) {
    this.options = {
      outputDir: options.outputDir ?? this.defaultOutputDir,
      createDir: options.createDir ?? true,
      header: options.header ?? this.getDefaultHeader()
    };
  }

  /**
   * Writes type definitions to a single file
   * @param filename - Output filename (without extension)
   * @param content - TypeScript code
   */
  async writeTypes(filename: string, content: string): Promise<void> {
    await this.ensureOutputDirectory();

    const filePath = path.join(this.options.outputDir, `${filename}.d.ts`);
    const fullContent = `${this.options.header}\n\n${content}`;

    await fs.writeFile(filePath, fullContent, 'utf-8');
  }

  /**
   * Writes multiple type definitions to separate files
   * @param types - Map of filename to content
   */
  async writeMultipleTypes(types: Map<string, string>): Promise<void> {
    await this.ensureOutputDirectory();

    const writePromises = Array.from(types.entries()).map(([filename, content]) =>
      this.writeTypes(filename, content)
    );

    await Promise.all(writePromises);
  }

  /**
   * Writes index file that exports all generated types
   * @param bundleNames - Array of bundle names to export
   */
  async writeIndexFile(bundleNames: string[]): Promise<void> {
    const lines: string[] = [
      this.options.header,
      '',
      '// Re-export all generated types',
      ...bundleNames.map(name => `export type { ${name} } from './${name}';`),
      ...bundleNames.map(name => `export { is${name} } from './${name}';`),
      ''
    ];

    const filePath = path.join(this.options.outputDir, 'index.d.ts');
    await fs.writeFile(filePath, lines.join('\n'), 'utf-8');
  }

  /**
   * Clears all generated type files
   */
  async clearTypes(): Promise<void> {
    try {
      const files = await fs.readdir(this.options.outputDir);
      const deletePromises = files
        .filter(f => f.endsWith('.d.ts'))
        .map(f => fs.unlink(path.join(this.options.outputDir, f)));
      
      await Promise.all(deletePromises);
    } catch (error) {
      // Directory might not exist, ignore
      // TODO: Consider logging this for debugging purposes
    }
  }

  /**
   * Ensures output directory exists
   */
  private async ensureOutputDirectory(): Promise<void> {
    if (!this.options.createDir) return;

    try {
      await fs.mkdir(this.options.outputDir, { recursive: true });
    } catch (error) {
      // Directory might already exist, check
      try {
        await fs.access(this.options.outputDir);
      } catch {
        throw new Error(`Failed to create output directory: ${this.options.outputDir}`);
      }
    }
  }

  /**
   * Gets default file header
   */
  private getDefaultHeader(): string {
    return `/**
 * Auto-generated by SyndrDB Type Generator
 * DO NOT EDIT THIS FILE DIRECTLY
 * 
 * Generated at: ${new Date().toISOString()}
 */`;
  }

  /**
   * Checks if output directory exists
   */
  async directoryExists(): Promise<boolean> {
    try {
      await fs.access(this.options.outputDir);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Lists all generated type files
   */
  async listGeneratedFiles(): Promise<string[]> {
    try {
      const files = await fs.readdir(this.options.outputDir);
      return files.filter(f => f.endsWith('.d.ts'));
    } catch {
      return [];
    }
  }

  /**
   * Gets output directory path
   */
  getOutputDirectory(): string {
    return this.options.outputDir;
  }
}
